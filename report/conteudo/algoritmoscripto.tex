\section{Algoritmos criptográficos}

\subsection{Advanced Encryption Standard - AES}

O AES é uma primitiva de criptografia que se destina a composição sistemas simétricos. É uma cifra de bloco, ou seja, divide a mensagem em blocos de tamanho fixo (128 bits, ou 16 bytes, no caso do AES). Como toda cifra de bloco, pode ser transformada numa cifra de fluxo (opera em dados de tamanho arbitrário) através de um modo de operação. Pode ser utilizada com chaves de 128, 192 ou 256 bits (o algoritmo Rijndael, que originou o AES, permite tamanhos diversos de chaves).

Em outras palavras, é um algoritmo que recebe como entrada para cifrar um bloco de 128 bits e uma chave do tamanho escolhido, e devolve uma saída também de 128 bits (criptograma). A decifragem recebe como entrada o criptograma (bloco de 128 bits) e devolve como saída um bloco de 128 bits. Se a chave for a correta, a saída será idêntica à mensagem original.

Para dimininuir a possibilidade de quebra da cifra, busca-se minimizar qualquer correlação visível entre a entrada e a saída, de modo que a mesma ] possa ser deduzida simplesmente observando-se um número muito grande de ccriptogramas (ou de pares mensagem/criptogramas). Então, usa-se uma série de rodadas em que os bytes sofrem transformações não lineares, porém reversíveis.

\subsubsection{Corpo de Galois}

Todas as operações no AES tratam os bytes de entrada como um corpo finito (ou corpo de Galois) em $2^{8}$ (ou GF($2^{8}$)). Define-se o conjunto e suas operações a seguir:

\begin{itemize}
\item O conjunto $[0,255]$ são todos os valores possíveis para um byte e um desses elementos é chamado ``zero'' (no caso, o próprio $0$);
\item A adição, que se aplica a quaisquer dois elementos nesse conjunto e cujo resultado também é um elemento desse conjunto, consiste na operação XOR (OU exclusivo). 
\item A multiplicação define-se escrevendo o byte na forma polinomial (cada bit é representado pelo coeficiente do polinômio do sétimo grau). Opera-se a multiplicação de maneira convencional, atentando somente a execução da soma dos monômios conforme definido no item acima (somar $x$ com $x$, por exemplo, teria como resultado $0x$, o que corresponde ao bit $0$). Após a obtenção do polinômio produto, faz-se a redução modular via $XOR$ com os coeficientes do polinômio redutor $x^{8}+x^{4}+x^{3}+x+1$ (alinhando-se os dígitos mais significativos), até a obtenção de um polinômio de grau menor que o redutor.
\end{itemize}

Em cada rodada são executados os procedimentos na seguinte ordem (exceto a última, que não possui o passo de trocar colunas):
\begin{enumerate}
\item S-BOX de Rijndael (ByteSub());
\item Deslocamento de linhas (ShiftRow())
\item Permutação de colunas (MixColumns())
\item Adição da chave de rodada (AddRoundKey())
\end{enumerate}

A seguir é descrito de forma mais minuciosa cada método executado.

\subsubsection{S-BOX de Rijndael}

Com base na aritmética em GF($2^{8}$), foi concebida uma tabela de consulta S-Box, destinada a transformar um byte em outro diferente, de uma forma não linear. Duas tabelas são usadas: uma para a função direta e outra pra inversa.
\begin{enumerate}
\item Em primeiro lugar, calcula-se o inverso multiplicativo do byte (byte que multiplicado pelo substituído gera o byte ``01''. O zero não tem inverso, então ele é mapeado para ele mesmo;
\item Em seguida, os oito bits do resultado são submetidos a uma transformação afim, para tornar o método mais resistente contra ataques algébricos, conforme $b'_{i}=b_{i}+b_{(i+4)mod 8}+b_{(i+5)mod 8}+b_{(i+6)mod 8}+b_{(i+7)mod 8}+c_{i}$, onde $b'_{i}$ é o novo bit, $b_{i}$ se refere ao bit de posição $i$ no byte substituído e $c_{i}$ se refere ao bit de posição $i$ no byte $63h$.
\end{enumerate}

O resultado é um novo bloco em que os bytes aparecem substituídos pelos obtidos na S-BOX. Essa tabela foi projetada com o objetivo de ser resistente à criptanálise linear ou diferencial, e permitindo a substituição da transformação afim por outra caso se descubra algum backdoor no futuro. Em resumo, é uma função invertível cuja saída não corresponde ao texto em claro.

\subsubsection{Deslocamento de linhas}

As linhas da matriz do bloco são ciclicamente deslocadas, onde a linha 0 permanece e demais são deslocada por um dado número de bytes. Os valores do deslocamento estão em função do tamanho do bloco e são descritos na tabela abaixo:
\begin{center}
	\begin{table}[H]
	    \begin{tabular}{|c|c|c|c|}
	    \hline
	    \textbf{$n_{colunas} \times n_{colunas\ de\ estado}$} & \textbf{1} & \textbf{2} & \textbf{3} \\ \hline
	    4                      & 1 & 2 & 3 \\ \hline
	    6                      & 1 & 2 & 3 \\ \hline
	    8                      & 1 & 3 & 4 \\ \hline
	    \end{tabular}
	\end{table}
\end{center}

\subsubsection{Permutação de Colunas}

Cada coluna de um estado é multiplicada e reduzida módulo $m(x) = x^{4} + 1$  por um polinômio constante $p(x) = 03h x^{3} + 01h x^{2}  + 01h x +02h$ na forma matricial, na chamada matriz circulante, onde os coeficientes do polinômio compõe a primeira coluna e as demais obtidas por permutação circular dos elementos da coluna. No caso de um bloco composto por 4 linhas, a matriz fica representada por:
 $$\begin{bmatrix}
 02&03&01&01\\
 01&02&03&01\\
 01&01&02&03\\
 03&01&01&02
 \end{bmatrix}$$

 \subsubsection{Adição da Chave de Rodada}

  Uma chave é adicionada ao estado utilizando um  $XOR$. A chave é derivada da chave K original através do procedimento Key Schedule() e possui tamanho igual ao bloco do estado. O procedimento Key Schedule() é feito da seguinte forma:
\begin{enumerate}
\item Total de chaves de rodada = $Tamanho do Bloco \times (Número de rodadas+1)$;
\item A chave K inicial  é expandida usando o procedimento KeyExpansion(), que depende do algoritmo AES utilizado (AES-128,AES-192 ou AES-256);
\item As chaves são extraidas da chave expandida de p em p words, onde p é o número de colunas do bloco cifrado, denominado estado. Em resumo, as $k_{i}$ chaves recebem as$i-ésimas$ words da chave expandida gerada pelo método KeyExpansion().
\end{enumerate}

Após o término das (10,12 ou 14) rodadas escolhidas, obtem-se o criptograma do texto de entrada.

Para decriptografar, basta executar as funções inversas baseadas em $GF(2^{8})$, seguindo a sequência reversa de transformações.

\subsection{Alleged Rivest's Cipher version 4 - ARC4}
asf 
\subsection{Blowfish}

\subsection{Data Encryption Standard - DES}

O algoritmo de criptografia \textit{Data Encryption Standard} foi desenvolvido pela IBM na década de 70, e foi largamente utilizado pela indústria, sendo escolhido pela NSA como um padrão para criptografia. \cite{stallings2011cryptography}

Esse é um algoritmo de bloco, ou seja, ele divide a mensagem em blocos (no caso do DES, de 8 bytes), e cada bloco é criptografado/decriptografado separadamente.

A criptografia consiste em 16 etapas, iterativamente, onde em cada etapa consiste em uma permutacao das metades do bloco, e da aplicação de uma funcao especifica sobre uma metade do bloco.

Essa operação específica consiste em permutações com expansão e aplicação da operação XOR, e a aplicação de S-boxes (caixas de substituição).

\subsection{Triple Data Encryption Standard - DES3}

O algoritmo Triplo DES é um reforço ao DES para aumentar a sua segurança. Ele é a aplicação do DES três vezes seguidas, utilizando chaves de 128 ou 192 bits. Quando se utiliza uma chave de 192 bits, esta é subdividida em 3 chaves de 64 bits ($K1$, $K2$ e $K3$). Caso a chave seja de 128 bits, está é dividida em 2 chaves ($K1$ e $K2$) e a terceira chave é adotada igual à segunda ($K2=K3$).

A aplicação se da pelo seguinte método (para criptografia)\cite{stallings2011cryptography}:
\begin{enumerate}
\item Primeiro encripta-se usando a primeira chave ($K1$)
\item Depois, decripta-se o resultado do primeiro passo usando a segunda chave ($K2$)
\item E, por ultimo, encripta-se novamente usando a terceira chave sobre o resultado do segundo passo ($K3$)
\end{enumerate}

A decriptografia se da fazendo o reverso da criptografia.