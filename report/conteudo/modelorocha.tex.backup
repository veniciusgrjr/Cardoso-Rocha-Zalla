%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% Exibir código fonte
%\begin{lstlisting}
%\end{lstlisting}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% Lista com pontos
% \begin{itemize}
%   \item item1
%   \item item2
% \end{itemize}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% Lista com números
%  \begin{enumerate}
%   \item item1
%   \item item2
% \end{enumerate}
 

\section{Modelo baseado no livro Caixa de Ferramentas DevOps}

\subsection{Ferramentas básicas: SSH, Git}

\subsubsection{SSH}

É o protocolo utilizado para conectar-se de forma 
segura em servidores. Por meio de criptografia ele 
cria um canal seguro entre duas máquinas. Também 
pode ser utilizado para executar comandos 
remotamente sem entrar no shell da máquina.
O Ansible, ferramenta que será usada mais afrente, 
só precisa de acesso por SSH.

Na maioria dos provedores, será encontrada uma 
opção para adicionar uma chave SSH pública.
Para criar uma chave RSA local segue-se os 
seguintes passos:
 \begin{enumerate}
   \item Digite o comando a seguir:
	
      \begin{lstlisting}
ssh-keygen -t rsa
      \end{lstlisting}
   
   \item Quando for perguntado sobre uma frase digite 
      enter duas vezes.
    \item Serão criados dois arquivos:
    \begin{lstlisting}
id_rsa_devops e id_rsa_devops.pub
    \end{lstlisting}
    
    \item Os arquivos com extenção .pub são os únicos 
	  que devem ser copiados para outras máquinas 
	  e representam as chaves públicas.

 \end{enumerate} 

\subsubsection{Git}

O Git é um sistema de controle de versão gratuita. 
Em termos práticos, sua função é controlar mudanças 
em repositórios de dados. Essa ferramenta controla 
repositórios de dados, pois, além de código-fonte de 
programas, também é possível controlar repositórios 
para a constução de livros, e qualquer outra 
atividade que em que várias pessoas trabalham ao 
paralelamente na sua construção.

Para instalar essa ferramenta, serão seguidos os 
seguintes passos:
  \begin{enumerate}
   \item Para linux baseado em debian:
      \begin{lstlisting}
sudo apt-get install git-core
      \end{lstlisting}
      
   \item Para linux CentOS/RH
      \begin{lstlisting}
sudo yum install git
      \end{lstlisting}
   
   \item Para MacOSX com homebrew
      \begin{lstlisting}
brew install git
      \end{lstlisting}
      
 \end{enumerate}
Após instalar o Git, execute os seguintes comandos 
para configurar um nome de usuário e um email: 

      \begin{lstlisting}
git config --global user.name "Seu nome"
git config --global user.email "seu@email.com.br"
      \end{lstlisting}

Nesse momento o ambiente está com o Git instalado 
e com nome e e-mail configurados. Será adotado 
agora um sistema para controlar os repositórios 
usados para construir o modelo de DevOps proposto.

O “Github” é um site que fornece um serviço de 
controle de repositórios remotos de “Git” sem custo,
caso o projeto seja aberto, e com custo caso o projeto 
seja privados. Para começar a utilizalo de forma 
gratuita, deve-se acessar o site “github.com” e criar 
uma conta. Neste ponto, será necessária a chave “ssh”, 
que está em:
      \begin{lstlisting}
~/.ssh/id_rsa.pub.
      \end{lstlisting}

Agora, será criado um novo repositório que posteriormente 
será sincronizado com o repositório local que estará em 
cada máquina que estiver trabalhando no projeto. Para criar 
esse repositório, basta seguir os paços do site clicando 
no botão de novo repositório. Para esse projeto, será dado 
o nome de projeto-simples. Agora, será criado um diretório 
local e, posteriormente, será feita a associação desse 
diretório local com o repositório remoto criado 
anteriormente no GitHub. Para isso, deve-se seguir os 
passos listados abaixo:

\begin{enumerate}
   \item Para criar o diretório local digite na linha de comando:
      \begin{lstlisting}
mkdir projeto-simples
      \end{lstlisting}
      
   \item Entre nesse diretório com:
      \begin{lstlisting}
cd projeto-simples
      \end{lstlisting}
   
   \item Com um editor de textos favorito, será criado um arquivo 
   de exemplo, com nome de README.md, para poder ser sincronizado 
   com o repositório remoto criado, explicando a função do projeto. 
   Será colocado o seguinte texto no arquivo:
   
      \begin{lstlisting}
# README do meu projeto-simples
      \end{lstlisting}
   
   \item Esse projeto será apenas um shell script que conta 
   itens únicos no diretório \/etc. Assim, será criaco o 
   seguinte script com o nome de itens\_unicos.sh:
   
      \begin{lstlisting}
#!/bin/sh
Echo "Itens unicos"
Ls /etc | cut -d" -f 1 | sort | uniq | wc -l
      \end{lstlisting}
      
 \end{enumerate}

Nesse momento, já foi criado o projeto simples que será 
sincronizado com o repositório remoto no github. Agora 
seguiremos os passos a seguir para realizar essa sincronização:

\begin{enumerate}
   \item Para iniciar o repositório Git no diretório local:
      \begin{lstlisting}
git init
      \end{lstlisting}
      
   \item Para adicionar todos os arquivos modificados ao 
   conjunto de modificações que serão enviadas para serem 
   sincronizadas com o repositório remoto: 
      \begin{lstlisting}
git add . 
      \end{lstlisting}
   
   \item Para criar uma mensagem, descrevendo as modificações: 
      \begin{lstlisting}
git commit -m "mensagem descrevendo a alteração"
      \end{lstlisting}
      
   \item Para vincular o repositório local ao repositório remoto: 
      \begin{lstlisting}
git remote add origin git@github.com:veniciusgrjr/projeto-simples.git
      \end{lstlisting}
      
    \item Para enviar as alterações: 
      \begin{lstlisting}
git push -u origin master
      \end{lstlisting}
	
 \end{enumerate}

Após isso, se a página do repositório remoto for atualizada, os 
arquivos locais estarão lá. Será feito agora um pequeno resumo 
dos comandos do Git:

\begin{itemize}

    \item Esse comando Inicia um repositório Git no 
    diretório atual.
	\begin{lstlisting}
Git init
	\end{lstlisting}
    \item Adiciona um ou mais arquivos para serem 
    enviados (commit) ao repositório.
	\begin{lstlisting}
Git add.
	\end{lstlisting}
    \item Confirma as mudanças e 
    cria um commit com uma mensaApós isso, faça reload da 
    página do repositório, e os arquivos locais estarão lá.
	\begin{lstlisting}
Git commit -m "mensagem"
	\end{lstlisting}    
    \item Esse comando adiciona um “remote” 
    ao repositório atual, chamado origin. Você poderia trabalhar 
    sem ter um remote, não é mandatório.
	\begin{lstlisting}
Git remote ...
	\end{lstlisting}
    \item Envia (push) as modificações 
    para o repositório remoto. O parametro -u só é necessário na 
    primeira execução.
	\begin{lstlisting}
Git push -u origin master
	\end{lstlisting}
    \item Cria uma cópia o repositório dado pela URL 
    para a máquina local em que foi digitado.
	\begin{lstlisting}
Git clone
	\end{lstlisting}
    \item Mostra o estado atual do repositório e 
    das mudanças.
	\begin{lstlisting}
Git status
	\end{lstlisting}
\end{itemize}

Agora, o diretório local será modificado e sincronizado 
com o repositório no Github. Para isso, será criado um 
arquivo com o nome de portas.sh, com o seguinte código:
    \begin{lstlisting}
#!/bin/sh
echo "Lista de porta 80 no netstat"
netstat -an | grep 80
    \end{lstlisting}
 
 Para adicionar essa modificação ao repositório no Github:
 
     \begin{lstlisting}
Git add portas.sh
Git commit -m "add portas.sh"
Git push origin master
    \end{lstlisting}
 
\subsection{Vagrant e Virtualbox}

Uma máquina virtual parada é uma imagem de um disco 
de metadados que descrevem sua configuração: processador, 
memória, discos e conexões externas. A mesma máquina em 
execução é um processo que depende de um scheduler( agendador 
de processos) para coordenar o uso dos recursos locais. Para 
gerenciar máquinas virtuais, pode-se usar as interfaces das 
aplicações VirtualBox, Parallels ou VMW, ou pode-se utilizar 
bibliotecas e sistemas que abstraem as diferenças entre 
essas plataformas, com interface consistente para criar, 
executar, parar e modificar uma máquina virtual.
Para criar e gerenciar os ambientes de máquinas virtuais 
locais, foi escolhido o Vagrant (www.vagrantup.com). 
Para executar as máquinas virtuais, foi escolhido o 
VirtualBox(www.virtualbox.org ).

O Vagrant gerencia e abstrai provedores de máquinas 
virtuais locais e públicos( VMWare, VirtualBox, Amazon 
AWS, DigitalOcean, entre outros). Ele tem uma linguagem 
especifica (DSL) que descreve o ambiente e suas máquinas. 
Além disso, ele fornece interface para os sistemas de 
gerenciamento de configuração mais comuns como Chef, 
Puppet, CFEngine e Ansible. Ele é um software que cria e 
configura ambientes 
virtuais de desenvolvimento. Possui interface de 
linha de comando simples para subir e interagir 
com esses ambientes virtuais. Essa ferramenta ajuda na 
criação da infraestrutura para o projeto, usando para 
isso uma máquina virtual. Nesse momento surge um questionamento: 
será preciso uma máquina virtual para cada projeto, isso não 
complicaria ainda mais o projeto? A resposta é não. O Vagrant 
deixa muita coisa invísivel, possibilitando se preocupar apenas 
com o código. Funciona como uma máquina virtual reduzida e 
portável. Para cada projeto é possível deixar 
um ambiente rodando PHP 4, outro PHP 5, outro Debian, outro em 
CentOS...

Para instalar o Virtualbox, basta acessar o site  
www.virtualbox.org, e seguir os passos de instalação. Após isso, 
para testar se tudo está funcionando, foi feito o download de 
uma ISO do ubuntu em www.ubuntu.com/download/server e testou-se 
a criação de máquinas virtuais.

Para instalar o Vagrant, foi acessado www.vagrantup.com e, 
foram seguidos os passos da instalação. Para criar uma 
máquina virtual usando o Vagrant seguiu-se os paços
abaixo:
\begin{enumerate}
   \item Foi criado um diretório chamado testvm. 
   \item Foi criado um arquivo chamado vagrantfile e 
   digitado nele:
      \begin{lstlisting}
# -*- mode: ruby -*-
# vi: set ft=ruby :

VAGRANTFILE_API_VERSION = “2”

Vagrant.configure( VAGRANTFILE_API_VERSION ) do |config|

	config.vm.define “testvm” do |testvm|
		testvm.vm.box = “ubuntu/trusty64”
		testvm.vm.network : private_network, ip : “192.168.33.21”
	end
	config.vm.provider “virtualbox” do |v|
		v.customize [“modifyvm”, :id, “--memory”, “1024”]
	end
end
      \end{lstlisting}
  \item no diretório desse arquivo criado,para subir o 
  servidor digitou-se:
    \begin{lstlisting}
vagrant up
    \end{lstlisting}

      \item Para testar, foi feita uma conexão com a 
      máquina virtual criada digitando-se:
    \begin{lstlisting}
vagrant ssh
    \end{lstlisting}
   \item É importante notar que dentro da máquina 
    o seu diretório local foi mapeado como um mount 
   point dentro da máquina virtual, acessando o 
   diretório vagrant digitando cd /vagrant é possível 
   observar isso. É possível criar este ponto com 
   outro nome ou deixar de criá-lo de acordo com a 
   configuração do Vagrantfile.
   \item Para destruir a máquina virtual criada, 
   basta digitar no terminal: 
    \begin{lstlisting}
vagrant destroy
//seguido de y, quando for perguntado se pode realmente destruir a máquina virtual
    \end{lstlisting}
\end{enumerate}

Assim, resumindo os comandos, temos:
\begin{enumerate}
   \item Para subir a máquina virtual:
    \begin{lstlisting}
vagrant up
    \end{lstlisting}
   \item Para subir a máquina virtual:
    \begin{lstlisting}
vagrant up
    \end{lstlisting}   
   \item Para subir a máquina virtual:
    \begin{lstlisting}
vagrant up
    \end{lstlisting}
   \item Para subir a máquina virtual:
    \begin{lstlisting}
vagrant up
    \end{lstlisting}    
  
\end{enumerate}



\subsubsection{Virtualbox}



\subsection{Ansible}
\subsection{Instalando Wordpress em uma máquina}

